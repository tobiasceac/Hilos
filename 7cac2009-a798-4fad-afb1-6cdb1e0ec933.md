IES INFANTA ELENA

# Programación de Servicios y Procesos

2° DAM-Ricardo Vicente

# TEMA 2

Programación Concurrente y Asincronía

## índice

Programación Didáctica

Resumen

Hilos

Hilos con Java

Estados de un hilo

Gestión de hilos

Gestión de hilos-Join

Gestión de hilos-Prioridades

Recursos compartidos y Sincronización

## PROGRAMACIÓN DIÓÁCTICA

![](images/28d170ec0c6300d2d173dd93624c8ae52c951b5daef076d78cd499d564769fd8.png)

## RESUMEN

### CONCURRENCIA Y ASINCRONÍA

Programación Secuencial: una instrucción sigue a otra instrucción después de que haya finalizado. Un solo núcleo y un hilo por núcleo.

Programación Concurrente: múltiples instrucciones de un programa funcionan al mismo tiempo. Múltiples núcleos, multiples hilos por núcleo.

Programación Paralela: utilización de técnicas de programación y arquitecturas hardware para que distintas instrucciones se ejecuten a la vez y al mismo tiempo. Múltiples núcleos.

![](images/9fc3d594e96aba612bd33f5c8ced374bcdff1759132139d38a8334950ae93622.png)

![](images/ce82c8cad47af5f1e5a5b683d2a2b8ec4c7f90452362fa32f0e1cdaec51ffd89.png)

![](images/d926f1c5d33c5d8c5a0984101644473278a1f28e262941d5d49ed77efc7e9793.png)

## RESUMEN

### Sincronía y Asincronía

Sincronía: toda la operación se ejecuta de forma secuencial y, por tanto, debemos esperar a que se complete para procesar el resultado, por lo que puede ser bloqueante.

Asincronía: la finalización de la operación se señaliza más tarde, mediante un mecanismo específico, por ejemplo un callback, una promesa o un evento (javascript)(el hilo se quedará permanente haciendo sus funciones), lo que hace que la respuesta sea procesada en diferido. Como se puede adivinar, su comportamiento es no bloqueante.

![](images/340253c26fb824e8ad4cbf1e725d86147618cda2c1a7d001f4ee5ac80eb21ab9.png)

![](images/386539afa2c503c39ad4a7272c6fc77a82bf212ed0644b95cf6d59aa88c0ae8b.png)

## RESUMEN

### RECURSOS COMPARTIDOS

Un proceso/hilo, entra en condición de competencia con otro, cuando ambos necesitan el mismo recurso, ya sea de forma exclusiva o no; por lo que será necesario utilizar mecanismos de sincronización y comunicación entre ellos.

Se llama sección crítica al conjunto de instrucciones en las que el proceso utiliza un recurso y que se deben ejecutar de forma exclusiva con respecto a otros procesos competidores por ese mismo recurso, asegurando la exclusión mutua.

Se dice que un proceso hace un lock (bloqueo) sobre un recurso cuando ha obtenido su uso en exclusion mutua.

Deadlock o interbloqueo: Se produce cuando los procesos no pueden obtener nunca los recursos necesarios para configurar su tarea. El interbloqueo es una situación muy peligrosa, ya que puede llevar al sistema a su caída o cuelgue.

## RESUMEN

### RECURSOS COMPARTIDOS

![](images/6b7c1133c708cb5d8cabb9723d09170f681c6c5520a4c1c393f8217f5d90ba60.png)

## RESUMEN

### PROGRAMACIÓN MULTIMÍLIO

![](images/9f1d34c89f2f54196f8f97537cfec5c1bdb5ff413a528552c0a63fd5e14d411d.png)

## RESUMEN

### PROGRAMACIÓN MULTIHILO

Un hilo es un objeto con capacidad de correr en forma concurrente y compartir el espacio de direcciones con otros hilos dentro del mismo proceso. Por lo tanto, un proceso puede tener varios hilos ejecutando acciones concurrentes. Al menos tiene uno (main).

Está limitado por el número de hilos/núcleos soportados por el sistema.

Un hilo puede compartir con otros hilos del mismo proceso:- Código- Datos (variables globales)

- Otros recursos del sistema operativo (como ficheros abiertos, sockets y señales)

Al llegar hasta aquí, os estaréis preguntando: si los hilos de un proceso comparten el mismo espacio de memoria, ¿qué pasa si uno de ellos la corrompe? La respuesta es que los otros hilos también sufrirán las consecuencias.

### ESTADOS DE UN HILO

![](images/62e287b0ca804b08ffe865a44676c09500147a0d122ffac1448e1a60ac85f621.png)

## RESUMEN

### ESTADOS DE UN HILO

Creación (LISTO), de ahí puede pasar a EN EJECUCIÓN, o no; esto dependerá del dispatcher.

Una vez en EJECUCIÓN, procesará su código hasta que se le acabe el tiempo asignado.

Puede pasar a LISTO, ESPERA, DORMIDO, SUSPENDIDO y BLOQUEADO.

Pasará a DORMIDO cuando se invoque al método sleep() y de ahí a LISTO.

Pasará a BLOQUEADO cuando tenga que sufrir una espera debido a una instrucción bloqueante; saldrá de este estado en cuanto termine. (Por ejemplo, el acceso a una BBDD).

El estado SUSPENDIDO es para los hilos que han quedado suspendidos (por ejemplo al pasar de memoria RAM a virtual) y deben resumirse.

## RESUMEN

### ESTADOS DE UN HILO

Pasarán a EN ESPERA cuando alguien invoque un wait(), entonces él esperará en un pool*. Hasta que se ejecute un notify() o un notifyall() para volver a reanudarse.

### -EXTRA-

*pool: Threadpool (framework ExecutorService) → Un Threadpool es un conjunto de hilos reutilizables que están disponibles para ejecutar múltiples tareas. En lugar de crear un nuevo hilo cada vez que se necesita ejecutar una tarea, las tareas se colocan en una cola y los hilos del pool se ejecutan en orden. Cada vez que un hilo finaliza una tarea, se puede volver a reutilizar. Esto permite reutilizar un conjunto fijo o dinámico de hilos para ejecutar multiples tareas, optimizando los recursos del sistema y mejorando el rendimiento.

## RESUMEN

### PROGRAMANDO CON HiLOS

Thread: clase responsable de producir hilos funcionales para otra clase.

Runnable: interfaz que proporciona la capacidad de añadir la funcionalidad de un hilo a una clase simplemente implementando la interfaz.

*(Executor-ExecutorService → ThreadPool, Callable, Future → operación asíncrona

## RESUMEN

### Sincronización y comunicación

Las variables atómicas son aquellas en las que su acceso y modificación se hacen de manera atómica mediante métodos get() y set().

*Cerrojos: simplemente cierran el paso al recurso compartido, hasta que terminan y lo vuelven a abrir. Pueden ser reentrantes (adquirido múltiples veces por el mismo hilo) o de acceso de lectura- escritura y lectura.

*Semáforos: variable especial que constituye el método para restringir o permitir el acceso a recursos compartidos.

## RESUMEN

### SINCronización y comunicación

Código sincronizado: fragmentos de código pertenecientes a una sección crítica, que estamos seguros que sólo pueden tener un hilo ejecutándose dentro de ellos al mismo tiempo.

*Monitores: estructura de datos que monitoriza la sección crítica. Es el encargado de hacer esperar, notificar a uno o a todos si está libre y asegurarse mediante espera activa que todos los interesados acceden al recurso de manera equitativa y segura, sin producir inanición y de forma exclusiva.

![](images/7e346da810feff464b1f3dc6dcc4f2393a50197bb589fc64f9a699e56e898b4d.png)

## RESUMEN

### EJEMPLOS – PRODUCTOR/CONSUMIDOR

El programa describe dos procesos, consumidor y productor, ambos comparten un buffer de tamaño finito. La tarea del productor es generar un producto, almacenarlo y comenzar nuevamente; mientras que el consumidor toma (simultáneamente) productos uno a uno. El problema consiste en que el productor no añada más productos que el tamaño del buffer y que el consumidor no intente tomar un producto si el buffer esta vacío.

![](images/74205c58976fe864c3b4c483a412fefc9ed8b229aa04b5982a0a3a261b6cb898.png)

### EJEMPLOS – LECTORES/ESCRITORES

Se produce si varios procesos pueden compartir un archivo o registro de datos. Tenemos varios “procesos de lectura” y otros “procesos de escritura”. Se permite que varios objetos lean un objeto compartido al mismo tiempo, pues no hay cambios en el fichero o recurso. Pero un proceso de escritura y otro proceso de lectura no pueden compartir el objeto al mismo tiempo.

![](images/b1881f9798d17d362b59bfa4aae1259303f10c5f24d1d9522d172356be088253.png)

## RESUMEN

### EJEMPLOS - FILÓSOFOS COMENSALES

Cinco filósofos se sientan alrededor de una mesa y pasan su vida pensando y cenando. Cada filósofo tiene un plato de fideos y un tenedor a la izquierda de su plato. Para comer los fideos es necesario dos tenedores y cada filósofo solo puede tomar los que están a su izquierda y derecha. Si cualquier filósofo toma un tenedor y el otro está ocupado, se quedará esperando, con el tenedor en la mano, hasta que pueda tomar el otro tenedor, para luego empezar a comer.

El problema consiste en encontrar un algoritmo que permita que los filósofos nunca se mueran de hambre/inanición, ni se produzca interbloqueo.

![](images/3db319cad5d4bcb3fb019b8ecbfec3e5c98e798e50b9201b656c0571ab7ebae1.png)

### EJEMPLOS – FILÓSOFOS COMENSALES

## Fin RESUMEN

## HiLOS

Los hilos los podríamos definir como diferentes líneas de ejecución de un mismo proceso, de modo que estamos refiriéndonos a un modo de programación concurrente, en la que los hilos comparten un espacio de memoria dentro del contexto de otro programa, mientras que los procesos generalmente mantienen su propio espacio de direcciones y entorno de operaciones. A los hilos se les llama procesos ligeros.

Los hilos no pueden ejecutarse solos, necesitan la supervisión de un proceso padre para ejecutarse.

Realización de programas que tengan que llevar a cabo tareas simultáneas

## HiLOS CON JAVA

### La clase Thread:

- Creación de una clase que herede de la clase Thread- Sobreescritura del método run()

- Llamada desde el programa padre mediante método start()

## HiLOS CON JAVA

1 Ejemplo 1 HiloEjemplo1

2 Ejemplo 2 Hilo Ejemplo1_V2 y UsaHiloEjemplo_V2

## HiLOS CON JAVA

Métodos clase Thread-start() -boolean isAlive() -sleep(long mils) -run() -String toString() -long getId() -void yield() -String getName() -setName(String name)

- int getPriority() - setPriority(int p) - void interrupt() - boolean interrupted() - Thread currentThread() - boolean isDaemon() - setDaemon(boolean on) - void stop() - int activeCount() - Thread.State.getState

## HiLOS CON JAVA

### 3

Ejemplo 3 HiloEjemplo2

### 4

Ejemplo 4 HiloEjemplo2Grupos

### Actividad 2.1

Crea dos clases (hilos) que extiendan la clase Thread. Uno de los hilos debe visualizar en pantalla en un bucle infinito la palabra TIC y el otro hilo la palabra TAC. Dentro del bucle utiliza el método sleep() para que nos de tiempo a ver las palabras que se visualizan cuando lo ejecutemos. Tendrás que añadir un bloque try-catch (para capturar la excepción InterruptedException). Crea después la función main() que haga uso de los hilos anteriores. ¿Se visualizan los textos TIC y TAC de forma ordenada?

## HiLOS CON JAVA

### La interfaz Runnable:

- Para añadir la funcionalidad de un hilo a una clase que deriva de otra clase (por ejemplo, un applet), siendo ésta distinta de Thread, se utiliza la interfaz Runnable. Esta interfaz añade la funcionalidad de hilo a una clase con solo implementarla.

- La interfaz Runnable proporciona un único método: run(). Este es ejecutado por el objeto hilo asociado.

## HiLOS CON JAVA

### Crear un hilo:

- Extender la clase Thread- Implementar la interfaz Runnable

**MiHilo mh = new MiHilo ("Hilo1");**

### Arrancar un hilo: start()

- Si extiende Thread: h.start();

- Si implementa la interfaz Runnable: new Thread(h).start();

## HiLOS CON JAVA

5

Ejemplo 5 Ejemplo Eunnable-EjemploRunnable

### Actividad 2.2

Transforma la Actividad 2.1 usando la interfaz Runnable para declarar el hilo. Después realiza el programa Java como indica el enunciado.

## ESTADOS DE UN HiLO

● NEW: cuando se crea un objeto hilo con new. Método getState() devuelve NEW

● RUNNABLE: cuando se invoca al método start() el hilo pasa a este estado. El sistema operativo tiene que asignar tiempo CPU al hilo para que se ejecute, por lo tanto puede estar o no en ejecución. Método getState() devuelve RUNNABLE

● DEAD: cuando haya muerto por razones “naturales”. (acaba el método run() o salta una excepción no controlada). Cuidado con el método stop() → salta excepción ThreadDeath y pueden quedar cosas por hacer como cerrar un fichero. Método getState() devuelve TERMINATED

## ESTADOS DE UN HiLO

- **BLOCKED:** cuando algo evita que el hilo se ejecute. Puede ser porque:- Se ha llamado al método sleep()

- El hilo está esperando a una acción de I/O- El hilo llama al método wait(). No se volverá ejecutable hasta recibir notify/notifyAll

- El hilo intenta bloquear un objeto bloqueado por otro hilo.

**Método getState() devuelve****BLOCKED:** cuando está esperando a tomar el bloqueo de un objeto.

**WAITING:** cuando espera a que otro realice una acción, por ejemplo, notify.

**TIMED_WAITING:** cuando espera la acción de otro un tiempo determinado.

## ESTADOS DE UN HiLO

![](images/e6d29091f9d38e93e2da23dadfd86f4426e2f1953cf8fac758c330a79fc732d3.png)

Blocked-Runnable: -done sleeping -I/O complete -notify -lock available

Runnable-Blocked: -sleep -block on I/O -wait -wait for lock

## ESTADOS DE UN HiLO

### ● Suspender*:

- sleep(ms): para un tiempo determinado de un hilo- Para suspender de forma segura se debe introducir en el hilo una variable y comprobar su valor dentro del método run().

## ESTADOS DE UN HiLO

6

Ejemplo 6 HiloEjemploDead

Actividad 2.4

7 Ejemplo 7 MyHilo-SolicitaSuspender

8

Ejemplo 8 Ejemplo GUI

## GESTIÓN DE HiLOS

● isAlive(): devuelve true si el hilo está vivo, es decir, ha llamado a su método run() y aún no ha terminado su ejecución o no ha sido detenido.

● interrupt(): envía una petición de interrupción a un hilo. Si el hilo se encuentra bloqueado por una llamada a sleep() o wait() se lanza una excepción InterruptedException.

● isInterrupted(): devuelve true si el hilo ha sido interrumpido (false en caso contrario)

## GESTIÓN DE HILOS

9 Ejemplo 9 HiloEjemplosinterrupt

## GESTIÓN DE HiLOS-JOIN-

● join(): el hilo que hace la llamada, espera la finalización de otros hilos.

## GESTIÓN DE HiLOS-JOIN-

### Parar hilos en Java

public class Hilo extends Thread { private boolean parar = false; // Por defecto el hilo no tiene que parar public void pararHilo() { this.parar = true; // Indicamos que el hilo debe pararse en cuanto pueda } public void run() { while (!parar) { // Mientras no se haya indicado que debe parar... // Hacer el trabajo } } }

## GESTIÓN DE HiLOS-JOIN-

Esperar a que finalicen hilos-Join

Hilo hilo01 = new Hilo("Hilo A", 5); Hilo hilo02 = new Hilo("Hilo B", 12);

hilo01.start(); hilo02.start();

try { hilo01.join(); hilo02.join(); } catch (InterruptedException e) { System.err.println("Error al hacer el join de hilos"); e.printStackTrace(); }

## GESTIÓN DE HiLOS-JOIN-

Esperar a que finalicen hilos-Espera activa

Hilo hilo01 = new Hilo("Hilo A", 5); Hilo hilo02 = new Hilo("Hilo B", 12);

hilo01.start(); hilo02.start();

while (hilo01.getState() != Thread.State.TERMINATED || hilo02.getState() != Thread.State.TERMINATED) { // Me duermo 1 s para que la espera no sea demasiado "intensa" con la CPU. Thread.sleep(1000); }

## GESTIÓN DE HiLOS-JOIN-

### Esperar a que finalicen hilos

En general, es mejor usar join (u otras formas de espera que veremos más adelante)

La única situación en la que suele usarse una espera activa es cuando sabemos que el hilo que hemos lanzado y por el que vamos a esperar va a tardar muy poco (del orden de nanosegundos o microsegundos). En este caso, la sobrecarga de la espera con join y cambios de contexto no compensa.

## GESTIÓN DE HiLOS-JOIÑ-

Ejemplo 10 Hilojoin-Ejemplojoin

## GESTIÓN DE HiLOS-PRIORIDADES-

Cada hilo tiene su prioridad. Por defecto, un hilo hereda la prioridad del hilo padre que lo crea, pero se puede aumentar o disminuir mediante el método setPriority(). Con el método getPriority() se recupera la prioridad que tenga un hilo.

Valores → Del 1 al 10 (MIN_PRIORITY, NORM_PRIORITY, MAX_PRIORITY)

El planificador es la parte de la JVM que decide qué hilo ejecutar en cada momento. Da más ventaja a hilos con mayor prioridad.

## GESTIÓN DE HiLOS-PRIORiDADES-

Todo esto que hemos comentado, no es tan claro y no parece cumplirse al 100%. El fin de esto, para controlarlo nosotros es la sincronización.

Consideraciones:- Cuidado al trabajar con constantes

- Cuidado en confiar en la prioridad de los ssoo- Para coordinar hilos, usaremos otros métodos mejores que las prioridades

## GESTIÓN DE HiLOS-PRiORiDADES-

Ejemplo 11 HiloPrioridad1-EjemploPrioridad1

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

En ocasiones, los hilos necesitan comunicarse entre ellos. Para eso podemos compartir un objeto entre ellos.

Información que suelen compartir:- Variables comunes- Ficheros- Bases de datos

Los hilos necesitarán en algún momento leer esta información compartida, y no debería haber problema de acceder a la vez.

El problema es cuando se va a escribir, a modificar la información compartida.

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-NECESIDADES-

Exclusión mutua: si varios hilos consiguen llegar de forma simultánea para realizar una modificación. La zona de código donde no se pueden ejecutar dos hilos a la vez se conoce como región crítica.

Condiciones de sincronización (ejemplos más adelante): necesidad de que los hilos se coordinen para que se realicen ciertas tareas en un orden necesario.

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-PROBLEMAS-

Violación de exclusión mutua: si varios hilos consiguen acceder de forma simultánea a una región crítica.

Interbloqueo (deadlock): cuando uno o varios hilos esperan a que ocurra algo que no va a pasar. Lo más habitual es que pase cuando se intenta acceder a recursos compartidos.

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

-PROBLEMAS-

Inanición: el algoritmo de control de los hilos no valora cuánto tiempo lleva esperando cada uno y alguno no llega a ejecutarse.

Injusticia: no hay un proceso “igualitario” en las tareas concurrentes.

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

-PROBLEMAS- CONDICIONES DE CARRERA -

El nombre viene de la idea de dos hilos compiten por ver quién llega antes a un recurso compartido.

La salida depende de un orden de ejecución de eventos sobre el que no tenemos control y que puede provocar resultados incorrectos.

Se convierte en un fallo siempre que el orden de ejecución no sea el esperado.*

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-PROBLEMAS- CONDICIONES DE CARRERA -

Los programas con condiciones de carrera tienen un comportamiento completamente imprevisible. Depende del orden en que se ejecuten los hilos, son:- Difíciles de detectar - Difíciles de reproducir - Difíciles de depurar

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-PROBLEMAS- CONDICIONES DE CARRERA -

Esto se va a producir cuando dos o más hilos acceden a la memoria compartida. En Java esto puede ocurrir de dos formas:

- Atributos estáticos: dos o más hilos acceden a un atributo público estático de otra clase, o, si son de la misma clase, a un atributo estático propio (público o privado).

- Con referencias al mismo objeto compartidos entre hilos.

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

12 Ejemplo 12 ComunicacionHilos: Contador, HiloA, HiloB y CompartirInf

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

### -REGÍÓN CRÍTICA-

Cuando se accede a un recurso compartido, decimos que estamos en una región o sección crítica.

La ejecución de la región crítica debe ser en exclusión mutua:

- Solo un hilo puede estar ejecutando el código de la región crítica- Hay que conseguir que los hilos se comuniquen para: pedir permiso para entrar en región crítica y avisar cuando abandona

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

-REGIÓN CRÍTICA-

A tener en cuenta:- Cuando ningún hilo esté en una región crítica, cualquier hilo que solicite su entrada lo hará sin demora.

- No se puede hacer suposiciones sobre la velocidad de los procesos ni el número de procesadores.

- Un proceso permanece en su sección crítica durante un tiempo finito.

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-Bloques sincronizados-

Para evitar que sucedan casos como en el ejemplo anterior (Ejemplo 12), lo que podemos hacer es que las operaciones de incremento y decremento del contador se hagan de forma atómica, es decir, si estamos realizando la suma nos aseguramos que nadie realice la resta hasta que no terminemos la suma. Esto se logra mediante bloques syncronized en la parte de código que queremos que ejecute de forma atómica.

De este modo java implemente las regiones críticas

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

13 Ejemplo 13 Bloques Sincronizados: Contador, HiloA, HiloB y Compartirlnf

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

-Métodos sincronizados-

En general se evita la sincronización de bloques de código y se sustituye siempre que sea posible por la SINCRONIZACIÓN DE MÉTODOS. El uso de métodos sincronizados implica que no es posible invocar dos métodos sincronizados del mismo objeto a la vez. Cuando un hilo está ejecutando un método sincronizado de un objeto, los demás hilos que invoquen métodos sincronizados para el mismo objeto se bloquean hasta que el primer hilo termine con la ejecución del método.

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

### -Métodos sincronizados-

Imaginemos la situación que dos personas comparten una cuenta y pueden sacar dinero de ella en cualquier momento; antes de retirar dinero se comprueba siempre si existe saldo.

La cuenta tiene 50€, una de las personas quiere retirar 40 y la otra 30. La primera llega al cajero, se revisa el saldo y como hay disponible, el cajero empieza a darle el dinero. En ese momento, antes de retirar el dinero de la cuenta, el segundo llega a otro cajero, se revisa el saldo y al no haber terminado la operación de retirada de dinero, le dice que

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-Métodos sincronizados-tiene saldo disponible y se dispone a retirar el dinero.

Lo lógico sería que a la segunda persona no le hubiera permitido retirar dinero por falta de saldo, o dejase un saldo de -20.

La solución a todo esto pasa por métodos sincronizados.

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

Ejemplo 14 Métodos sincronizados: Cuenta, SacarDinero, Compartirlnf

Actividad 2.5

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-Métodos sincronizados-

Extra: Semáforos, Monitores, synchronized (pag. 16 – pag. 23 → Ampliación Tema 2 (Recursos compartidos y sincronización))

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

15 Ejemplo 15 Bloqueo de Hilos1: ObjetoCompartido, BloqueoHilos1, HiloCadena1

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-Bloqueo de Hilos-

Si lo que se pretende es que la salida de la función main() sea “A B A B A B ...” no lo conseguiremos. La sincronización evita que dos llamadas se mezclen, pero no garantiza el orden de las llamadas.

Se necesita por tanto mantener una cierta coordinación entre los dos hilos. Para ello se usan lo métodos wait(), notify() y notifyAll().

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-Bloqueo de Hilos--wait(): un hilo que llama al método wait() de un cierto objeto queda suspendido hasta que otro hilo llame al método notify() o notifyAll() del mismo objeto. -notify(): despierta solo a uno de los hilos que realizó una llamada a un wait(). -notifyAll(): despierta todos los hilos que están esperando el objeto.

## RECURSOS COMPARTIDOS Y SINCROnIZACIÓN

16 Ejemplo 16 Bloqueo de Hilos2: ObjetoCompartido, BloqueoHilos2, HiloCadena2

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

### -Bloqueo de Hilos- Monitores

Un monitor es una estructura de datos diseñada para ser utilizada de forma segura por más de un hilo de ejecución. En Java, un monitor es un objeto de una clase diseñada específicamente para su uso compartido. En esta clase usaremos:

- Modificador synchronized: conseguir exclusión mutua en métodos

- Método wait: bloquear un hilo que ha llamado a un método del monitor

- Métodos notify y notifyAll: desbloquear hilos que quedaron bloqueados en un wait

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

### -Bloqueo de Hilos- Monitores - wait

Sirve para bloquear un hilo de ejecución. Se usa dentro de exclusión mutua. Normalmente está asociado a cierta condición. Por ejemplo, si no hay datos para consumir, quedarme bloqueado hasta que los haya.

- wait(): se bloquea el hilo hasta que otro llame a notify() o notifyAll()

- wait(long timeout): igual que la anterior, pero también se desbloquea si pasa el tiempo indicado en ms

- wait(long timeout, long nanos): igual que la anterior, pero podemos afinar más el tiempo, ms+ns

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

### -Bloqueo de Hilos- Monitores - wait

El método wait suele usarse junto a una condición. Si cierta condición no se cumple, el hilo se bloquea. Si se cumple, se continúa. Para esta condición debe usarse un while. ¿Por qué?

El planificador puede desbloquear múltiples hilos bloqueados previamente. Al volver a ejecutarse, deben volver a evaluar la condición. Si sigue sin cumplirse se deberán bloquear de nuevo.

Ejemplo de uso: si una cola (LinkedList) está vacía, bloquearse: while(cola.isEmpty()) wait();

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

-Bloqueo de Hilos- Monitores - notify

Desbloquea un único hilo bloqueado por una llamada previa a wait(). Si hay más de un hilo bloqueado, no hay garantías de qué hilo se desbloqueará. Elige el planificador según su política de asignación. El hilo desbloqueado no puede asumir que será el siguiente en ejecutarse. Debe suponer que tendrá que competir con otros hilos por los recursos, y otro hilos puede haberse “colado” antes. Se usa tras cambiar algo que podía provocar el bloqueo de otros hilos.

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-Bloqueo de Hilos- Monitores - notifyAll

Exactamente igual que notify, pero desbloquea todos los hilos que estaban esperando en un wait.

Ejemplo: En el caso de la cola (LinkedList) que hemos visto antes, un hilo que se encarga de añadir elementos en la cola, tras añadir un elemento llamaría a notify() o notifyAll().

cola.addLast(item); notify(); //Esto desbloquea un hilo que esperaba. //Si usamos notifyAll() se desbloquean todos.

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-Bloqueo de Hilos- Monitores – wait/notify

Las llamadas a notify y notifyAll, si no hay ningún hilo esperando en un wait(), se “pierden”. Es decir, no sirven para desbloquear hilos que hagan un wait() a posteriori. Esta es una de las diferencias con los semáforos. Los signal() en los semáforos incrementaban un contador que servía para que luego “entraran” otros hilos. Además, las llamadas a wait/notify/notifyAll sólo deben hacerse desde métodos sincronizados del objeto monitor.

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-Bloqueo de Hilos- Monitores – Estados

Cuando llega a método synchronized, antes de entrar  RUNNABLE • Si puede pasar, entra, y sigue en RUNNABLE • Si no puede pasar  BLOCKED

Cuando llega al wait(), antes de ejecutarlo  RUNNABLE Cuando ejecuta el wait  WAITING Otra tarea puede pasar de BLOCKED  RUNNABLE

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

-Bloqueo de Hilos- Monitores – Estados

Cuando llega un notify() o notifyAll()

• WAITING → BLOCKED (el wait estaba dentro de syncronized)

• Cuando entra BLOCKED → RUNNABLE – Continúa tras el wait.

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

### -Bloqueo de Hilos- Monitores – Estados

Es una buena práctica encapsular todo lo relacionado con la sincronización en el monitor, de forma que los hilos que usan el monitor no tengan que hacer operaciones específicas.

• El recurso que el monitor está “protegiendo” debe ser un atributo privado del monitor.

• El acceso a este recurso se hará con métodos públicos synchronized.

• Dentro de los métodos synchronized (o en métodos que llamemos de estos) evaluaremos la condición necesaria y haremos las llamadas a wait y a notify / notifyAll

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

![](images/fa209db4f46dfbb89d8b12f685ecb77badd7c6543faf3618babb8dbc23abc095.png)

### -Productor/Consumidor-

El modelo Productor-Consumidor: problema típico de sincronización.

- Uno o más hilos producen datos a procesar (Productor) y otro(s) hilo(s) los consumen (Consumidor).

- Problema: el productor produce datos más rápido que el consumo del consumidor/el consumidor consume datos más rápido de lo que el productor los produce.

## RECURSOS COMPARTIDOS Y SINCROMIZACIÓN

-Productor/Consumidor-

Los hilos deben trabajar coordinadamente en cuanto al acceso a un elemento común, el “buffer”.

El “buffer” es un monitor que se encarga de la coordinación y sincronización de la entrada (producción) y salida (consumición) de valores.

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

![](images/59a8b1ca6301b9ae086396244c737dabe3dfbe43788cfd4b075f7c87ce6fb914.png)

-Productor/Consumidor-

![](images/46055a3cb689ac27506f4779021c193b1607d050eb6ae04b25db4beffc8f0ed9.png)

## RECURSOS COMPARTIDOS Y SINCRONIZACIÓN

![](images/59a8b1ca6301b9ae086396244c737dabe3dfbe43788cfd4b075f7c87ce6fb914.png)

### -Productor/Consumidor-

Ejemplo: Crea un programa Java con:- Clase “Productor” que genera números aleatorios- Clase “Consumidor” que procese los números aleatorios, calculando su factorial.

- Una clase “ColaNumeros” que funcione como mecanismo de sincronización.

Enunciado ejemplo – Ejercicios Ampliación 03-10

## PRÁCTICAS AVANZADAS

ASINCRONÍA

100 MONTAJITOS

HOTLIN – JAMONES“Si queremos contar líneas de código, no deberíamos referirnos a ellas como líneas producidas, sino como líneas

consumidas.”

Edsger Dijkstra